from fiber import Fiber
from fiber import current
from fiber import suspend
from .errors import TcpError
from .server import Server

c"""
class WriteRequest {
public:
    uv_buf_t m_buf;
    uv_write_t m_request;
    Bytes m_data;
};

static void on_connect_complete(uv_connect_t *request_p, int status)
{
    Client *client_p = (Client *)(request_p->data);

    client_p->_status = status;
    resume(client_p->_fiber);
}

static void on_read_complete(uv_stream_t *request_p,
                             ssize_t nread,
                             const uv_buf_t* buf_p)
{
    Client *client_p = (Client *)(request_p->data);
    bool completed = false;

    if (nread > 0) {
        client_p->_read_offset += nread;

        if (client_p->_read_offset == client_p->_read_data.m_bytes->size()) {
            completed = true;
        }
    } else if (nread < 0) {
        completed = true;
        client_p->_read_data.m_bytes->resize(0);
    }

    if (completed) {
        uv_read_stop(request_p);
        resume(client_p->_fiber);
    }
}

static void read_alloc(uv_handle_t *handle_p, size_t size, uv_buf_t *buf_p)
{
    Client *client_p = (Client *)(handle_p->data);

    buf_p->base = ((char *)client_p->_read_data.m_bytes->data()
                   + client_p->_read_offset);
    buf_p->len = client_p->_read_data.m_bytes->size() - client_p->_read_offset;
}

static void on_write_complete(uv_write_t *request_p, int status)
{
    WriteRequest *write_request_p = (WriteRequest *)(request_p->data);

    if (status != 0) {
        std::cout << "ToDo: TCP write failed." << std::endl;
        exit(1);
    }

    delete write_request_p;
}

static void on_getaddrinfo_complete(uv_getaddrinfo_t *resolver_p,
                                    int status,
                                    struct addrinfo *info_p)
{
    Client *client_p = (Client *)(resolver_p->data);

    if (status < 0) {
        fprintf(stderr, "getaddrinfo callback error %s\n", uv_err_name(status));
        return;
    }

    client_p->m_connect.data = client_p;
    uv_tcp_connect(&client_p->m_connect,
                   &client_p->m_socket,
                   (const struct sockaddr*)info_p->ai_addr,
                   on_connect_complete);
    uv_freeaddrinfo(info_p);
}
"""

class Client:
    c"uv_tcp_t m_socket;"
    c"uv_connect_t m_connect;"
    c"struct addrinfo m_hints;"
    c"uv_getaddrinfo_t m_resolver;"
    c"uv_buf_t m_buf;"
    _read_data: bytes
    _read_offset: u32
    _fiber: Fiber
    _status: i32

    def __init__(self):
        c"""
        uv_tcp_init(uv_default_loop(), &m_socket);
        m_socket.data = this;
        """

        self._fiber = None

    def _ensure_one_caller(self):
        if self._fiber is not None:
            raise TcpError("Only one fiber may perform blocking operations.")

    def connect(self, host: string, port: u32):
        """Connect to a server using given `host` and `port`.

        """

        self._ensure_one_caller()

        host_utf8 = host.to_utf8()
        host_utf8 += 0
        port_utf8 = str(port).to_utf8()
        port_utf8 += 0
        self._fiber = current()

        c"""
        m_resolver.data = this;

        m_hints.ai_family = PF_INET;
        m_hints.ai_socktype = SOCK_STREAM;
        m_hints.ai_protocol = IPPROTO_TCP;
        m_hints.ai_flags = 0;

        uv_getaddrinfo(uv_default_loop(),
                       &m_resolver,
                       on_getaddrinfo_complete,
                       (const char *)host_utf8.m_bytes->data(),
                       (const char *)port_utf8.m_bytes->data(),
                       &m_hints);
        """

        suspend()
        self._fiber = None

        if self._status != 0:
            raise TcpError("Connect failed.")

    def disconnect(self):
        """Disconnect from the server.

        """

        raise NotImplementedError()

    def write(self, data: bytes):
        """Write data to the server.

        """

        c"""
        WriteRequest *request_p = new WriteRequest();
        request_p->m_buf = uv_buf_init((char *)data.m_bytes->data(),
                                       data.m_bytes->size());
        request_p->m_request.data = request_p;
        request_p->m_data = data;
        uv_write(&request_p->m_request,
                 (uv_stream_s *)&m_socket,
                 &request_p->m_buf,
                 1,
                 on_write_complete);
        """

    def read(self, size: u32) -> bytes:
        """Read data from the server. Always returns exactly given number of
        bytes, or no data if disconnected.

        """

        self._ensure_one_caller()

        self._read_offset = 0;

        c"""
        _read_data = Bytes(size);
        uv_read_start((uv_stream_t*)&m_socket, read_alloc, on_read_complete);
        """

        self._fiber = current()
        suspend()
        self._fiber = None

        data = self._read_data
        self._read_data = None

        return data

class _ServerCommunicationFiber(Fiber):
    server: Server

    def run(self):
        client = self.server.accept()
        assert client.read(1) == b"1"
        assert client.read(9) == b"234567890"
        client.write(b"0")
        client.write(b"987654321")

@test
def test_server_communication():
    port: u32 = 50222

    server = Server()
    server.listen(port)
    server_fiber = _ServerCommunicationFiber(server)
    server_fiber.start()

    client = Client()
    client.connect("localhost", port)
    client.write(b"123456789")
    client.write(b"0")
    assert client.read(9) == b"098765432"
    assert client.read(1) == b"1"
